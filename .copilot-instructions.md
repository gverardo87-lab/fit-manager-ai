# ğŸ‹ï¸ FitManager AI Studio - Copilot Instructions

**Version**: 4.0.0 (SSOT Edition)  
**Last Updated**: February 17, 2026  
**Philosophy**: Code is Truth. Documentation follows implementation.

---

## ğŸ¯ PROJECT IDENTITY

**What is FitManager AI?**  
AI-powered fitness studio management platform for personal trainers. Manages clients, schedules, assessments, workout programming (RAG-based), and financial intelligence. Privacy-first (local LLM), GDPR-ready.

**Core Value Proposition**: Professional-grade CRM + AI workout generation without cloud vendor lock-in.

---

## ğŸ—ï¸ CORE ARCHITECTURE

### Stack (Immutable)
```python
# Frontend
streamlit==1.36.0  # Multi-page app

# Backend
Python 3.9+
SQLite (crm.db, schedule.db)

# AI/RAG
ollama  # Local LLM (llama3.2, mistral, qwen2.5)
langchain + langchain-ollama
chromadb==0.4.24
sentence-transformers  # nomic-embed-text

# Validation & Data
pydantic>=2.0
pandas==2.2.2

# Visualization
plotly==5.22.0
```

### Design Patterns (Mandatory)

#### 1. Separation of Concerns
```
server/pages/*.py  â†’  UI only (Streamlit)
       â†“ calls
core/*.py  â†’  Business logic, DB access, validation
```

**Rule**: NEVER put business logic in Streamlit pages. NEVER put `st.` calls in `core/`.

#### 2. Validation-First Flow
```
User Input â†’ Pydantic Model â†’ Validation â†’ DB Operation â†’ UI Response
```

**Example**:
```python
# âœ… CORRECT
from core.models import ClienteCreate

data = ClienteCreate(nome=nome, cognome=cognome, email=email)  # Validates
db.aggiungi_cliente(data.model_dump())  # Already validated

# âŒ WRONG
db.aggiungi_cliente(nome=nome, cognome=cognome, email=email)  # No validation!
```

#### 3. Error Handling (Centralized)
```python
# âœ… CORRECT
from core.error_handler import safe_operation

@safe_operation(operation_name="Salva Cliente")
def aggiungi_cliente(self, data: dict) -> int:
    # DB logic
    pass

# âŒ WRONG
try:
    db.execute(...)
except Exception as e:
    st.error(f"Errore: {e}")  # Inconsistent error handling
```

#### 4. Database Operations (Context Managers)
```python
# âœ… CORRECT
def get_cliente(self, id_cliente: int) -> dict:
    with self.get_connection() as conn:
        cur = conn.cursor()
        cur.execute("SELECT * FROM clienti WHERE id = ?", (id_cliente,))
        return cur.fetchone()

# âŒ WRONG
conn = sqlite3.connect("crm.db")
cur = conn.cursor()
# ... forget to close connection
```

#### 5. RAG System (Hybrid Approach)
```
Local Exercise DB (200+ exercises, always available)
         +
Optional Knowledge Base (PDFs ingested by user)
         â†“
Combined Context â†’ LLM Generation
```

**Rule**: RAG must work even if KB is empty (fallback to built-in exercises).

---

## ğŸš« CODE IS TRUTH RULES (Anti-Patterns)

### What You Must NEVER Do

1. **Don't Use Magic Strings**
```python
# âŒ WRONG
cur.execute("SELECT * FROM clienti WHERE stato = 'ATTIVO'")

# âœ… CORRECT
from core.models import ClienteStatus
cur.execute("SELECT * FROM clienti WHERE stato = ?", (ClienteStatus.ATTIVO.value,))
```

2. **Don't Bypass Pydantic Validation**
```python
# âŒ WRONG
def save_measurement(peso: float, grasso: float):
    conn.execute("INSERT INTO misurazioni ...")

# âœ… CORRECT
def save_measurement(data: MisurazioneCreate):
    # Pydantic already validated types, ranges, constraints
    conn.execute("INSERT INTO misurazioni ...", data.model_dump())
```

3. **Don't Mix UI and Logic**
```python
# âŒ WRONG (in server/pages/02_Clienti.py)
if st.button("Salva"):
    conn = sqlite3.connect("crm.db")
    conn.execute("INSERT INTO ...")  # DB logic in UI!

# âœ… CORRECT
if st.button("Salva"):
    db = CrmDBManager()
    db.aggiungi_cliente(data)  # UI calls core
```

4. **Don't Assume Future Features as Existing**
```python
# âŒ WRONG
# Assuming mobile app integration exists
from core.mobile_api import send_push_notification  # Doesn't exist!

# âœ… CORRECT
# Check if module exists first, or implement it
```

5. **Don't Hardcode Sensitive Data**
```python
# âŒ WRONG
STRIPE_KEY = "sk_live_xxxxx"

# âœ… CORRECT
from dotenv import load_dotenv
load_dotenv()
STRIPE_KEY = os.getenv("STRIPE_API_KEY")
```

6. **Don't Trust User Input**
```python
# âŒ WRONG
query = f"SELECT * FROM clienti WHERE email = '{user_email}'"  # SQL injection!

# âœ… CORRECT
cur.execute("SELECT * FROM clienti WHERE email = ?", (user_email,))
```

7. **Don't Put Business Logic in LLM Prompts**
```python
# âŒ WRONG
prompt = f"Calculate MRR for client {id}"  # LLM unreliable for math

# âœ… CORRECT
mrr = financial_analytics.calculate_mrr(id)  # Python function (deterministic)
```

---

## ğŸ§  AI THOUGHT PROCESS (How to Code)

### Before Writing Any Feature

**Step 1: Define the Model**
```python
# core/models.py
class NuovaEntity(BaseModel):
    campo1: str = Field(..., min_length=1)
    campo2: Optional[int] = None
```

**Step 2: Add DB Method**
```python
# core/crm_db.py (or relevant DB module)
@safe_operation("Aggiungi Entity")
def aggiungi_entity(self, data: NuovaEntity) -> int:
    with self.get_connection() as conn:
        cur = conn.cursor()
        cur.execute("INSERT INTO entities ...", data.model_dump())
        return cur.lastrowid
```

**Step 3: Create UI**
```python
# server/pages/XX_Feature.py
from core.models import NuovaEntity
from core.crm_db import CrmDBManager

with st.form("form_entity"):
    campo1 = st.text_input("Campo 1*")
    campo2 = st.number_input("Campo 2")
    
    if st.form_submit_button("Salva"):
        try:
            entity = NuovaEntity(campo1=campo1, campo2=campo2)
            db = CrmDBManager()
            id_new = db.aggiungi_entity(entity)
            st.success(f"âœ… Entity {id_new} creata")
        except ValidationError as e:
            st.error(f"Errore validazione: {e}")
```

### When Modifying Existing Code

**Ask yourself**:
1. Is there a Pydantic model for this data? (Check `core/models.py`)
2. Is there a DB method? (Check `core/crm_db.py`, `core/schedule_db.py`)
3. Is error handling applied? (Look for `@safe_operation`)
4. Am I mixing UI and logic? (Separate them!)

---

## ğŸ—‚ï¸ FILE STRUCTURE RULES

```
core/
â”œâ”€â”€ models.py          # ALL Pydantic models (single source of truth for schemas)
â”œâ”€â”€ crm_db.py          # Client, measurements, contracts, workout plans
â”œâ”€â”€ schedule_db.py     # Appointments, sessions
â”œâ”€â”€ financial_analytics.py  # MRR, churn, margin calculations (immutable logic)
â”œâ”€â”€ exercise_database.py    # Exercise database (72 exercises)
â”œâ”€â”€ workout_generator_v2.py # Workout generation engine
â”œâ”€â”€ knowledge_chain.py      # RAG retriever, embeddings
â”œâ”€â”€ error_handler.py        # Decorators, logging
â”œâ”€â”€ config.py               # Paths, constants, environment vars
â””â”€â”€ ...

server/
â”œâ”€â”€ app.py             # Main dashboard (KPI cards, navigation)
â””â”€â”€ pages/
    â”œâ”€â”€ 01_Agenda.py              # Calendar/scheduling UI
    â”œâ”€â”€ 03_Clienti.py             # CRM UI (clients, measurements)
    â”œâ”€â”€ 04_Cassa.py               # Financial UI (cash flow, invoices)
    â”œâ”€â”€ 06_Assessment_Allenamenti.py  # Assessment UI
    â”œâ”€â”€ 07_Programma_Allenamento.py   # Workout generation UI (RAG)
    â”œâ”€â”€ 09_Financial_Intelligence.py  # Financial analytics dashboard
    â””â”€â”€ ...

knowledge_base/
â”œâ”€â”€ documents/         # User-uploaded PDFs (training manuals, etc.)
â”œâ”€â”€ vectorstore/       # ChromaDB persistence
â”œâ”€â”€ ingest.py          # PDF â†’ chunks â†’ embeddings â†’ ChromaDB
â””â”€â”€ ask.py             # Console RAG query interface

data/
â”œâ”€â”€ crm.db             # SQLite: clients, measurements, contracts, workouts
â””â”€â”€ ...
```

---

## ğŸ” SECURITY & PRIVACY (Non-Negotiable)

1. **Local LLM Only** (Default: Ollama)
   - Cloud LLM (OpenAI, Anthropic) only as documented fallback
   - Never send PII (names, emails, health data) to cloud

2. **Parameterized Queries Always**
```python
# âœ… CORRECT
cur.execute("SELECT * FROM clienti WHERE id = ?", (id_cliente,))

# âŒ WRONG
cur.execute(f"SELECT * FROM clienti WHERE id = {id_cliente}")  # SQL injection risk
```

3. **Environment Variables for Secrets**
```python
# .env (gitignored)
STRIPE_API_KEY=sk_test_xxxxx

# Python code
from dotenv import load_dotenv
load_dotenv()
STRIPE_KEY = os.getenv("STRIPE_API_KEY")
```

4. **No PII in LLM Prompts**
```python
# âŒ WRONG
prompt = f"Create workout for Mario Rossi, age 35, email mario@test.com"

# âœ… CORRECT
prompt = f"Create workout for male, age 35, intermediate level, goal: hypertrophy"
```

---

## ğŸ§ª TESTING MINDSET

**Current State**: Minimal tests (known gap).

**When Adding Tests** (future):
1. Test Pydantic models (`tests/test_models.py`)
2. Test DB operations (`tests/test_crm_db.py`)
3. Mock external APIs (Ollama, weather)
4. Use `pytest` + `pytest-cov` for coverage

**Example Test**:
```python
# tests/test_models.py
from core.models import ClienteCreate
from pydantic import ValidationError
import pytest

def test_cliente_valid():
    data = ClienteCreate(nome="Mario", cognome="Rossi", email="mario@test.com")
    assert data.nome == "Mario"

def test_cliente_invalid_email():
    with pytest.raises(ValidationError):
        ClienteCreate(nome="Mario", cognome="Rossi", email="invalid")
```

---

## ğŸ¨ UI/UX CONVENTIONS

### Streamlit Patterns

**Page Structure** (Consistent):
```python
st.set_page_config(page_title="Feature Name", page_icon="ğŸ¯", layout="wide")

st.title("ğŸ¯ Feature Name")
st.markdown("Brief description")

# Sidebar for filters
with st.sidebar:
    st.header("âš™ï¸ Filters")
    filtro = st.selectbox("Filter by", options)

# Main content
col1, col2 = st.columns([2, 1])
with col1:
    # Primary content
    pass
with col2:
    # Stats/KPIs
    pass
```

**Forms** (Always use `st.form` for grouped inputs):
```python
with st.form("form_name"):
    col1, col2 = st.columns(2)
    with col1:
        campo1 = st.text_input("Campo 1*")
    with col2:
        campo2 = st.number_input("Campo 2")
    
    submitted = st.form_submit_button("ğŸ’¾ Salva", use_container_width=True)
```

**Color Scheme** (Defined in `server/app.py`):
- Primary: `#0066cc` (Blue) - CTAs
- Secondary: `#00a86b` (Green) - Success
- Accent: `#ff6b35` (Orange) - Warnings
- Danger: `#e74c3c` (Red) - Errors

---

## ğŸ“š TERMINOLOGY (Glossary)

| Term | Meaning |
|------|---------|
| **CRM** | Client Relationship Management (clienti, misurazioni, anamnesi) |
| **RAG** | Retrieval-Augmented Generation (AI + knowledge base) |
| **KB** | Knowledge Base (PDFs uploaded by user) |
| **LLM** | Large Language Model (Ollama models: llama3.2, mistral, qwen) |
| **MRR** | Monthly Recurring Revenue |
| **Churn** | Client attrition rate |
| **PT** | Personal Trainer |
| **SSOT** | Single Source of Truth (code is truth, not docs) |
| **DTO** | Data Transfer Object (Pydantic models) |

---

## ğŸ”„ WORKFLOW (Standard Feature Development)

1. **Define Schema**: Add Pydantic model to `core/models.py`
2. **DB Method**: Add CRUD method to relevant `core/*_db.py`
3. **Error Handling**: Use `@safe_operation` decorator
4. **UI**: Create Streamlit page in `server/pages/`
5. **Test** (if applicable): Add test to `tests/`
6. **Document** (if user-facing): Update `README.md` (brief)

---

## ğŸš€ COMMON COMMANDS

```powershell
# Activate environment
.\venv\Scripts\Activate.ps1

# Run app
streamlit run server/app.py

# Check Ollama models
ollama list

# Pull new LLM
ollama pull qwen2.5

# Database inspection
sqlite3 data/crm.db
# .tables
# .schema clienti
# SELECT * FROM clienti;
# .quit

# Install dependency
pip install <package>
# Update pyproject.toml manually
```

---

## ğŸ› DEBUGGING CHECKLIST

Before asking "Why doesn't this work?", check:

1. âœ… Is Ollama running? (`ollama list`)
2. âœ… Are databases initialized? (check `data/` folder)
3. âœ… Is virtual environment activated? (see `(venv)` in terminal)
4. âœ… Are dependencies installed? (`pip list`)
5. âœ… Check `logs/` folder for errors
6. âœ… Is the Pydantic model defined? (`core/models.py`)
7. âœ… Is the DB method using `@safe_operation`?
8. âœ… Are you using parameterized queries? (anti SQL-injection)

---

## ğŸ“– CONTEXT FOR AI ASSISTANTS

### When I Ask You to Add a Feature

**You should**:
1. Check if a Pydantic model exists (`core/models.py`)
2. Check if a DB method exists (`core/crm_db.py`, etc.)
3. Use `@safe_operation` for error handling
4. Separate UI (Streamlit) from logic (core)
5. Validate with Pydantic before DB operations
6. Use Italian for UI text, English/Italian for code comments

**You should NOT**:
- Create duplicate validation logic
- Put DB operations in Streamlit pages
- Use string concatenation for SQL queries
- Assume features exist without checking code
- Suggest cloud AI without fallback justification
- Hardcode sensitive data

### When I Ask You to Fix a Bug

**You should**:
1. Ask for the error message/traceback
2. Check if the error is already handled by `@safe_operation`
3. Verify Pydantic validation is in place
4. Check DB schema matches the model
5. Suggest minimal fix (don't refactor entire modules)

---

## âœ… FINAL CHECKLIST (Before Committing Code)

- [ ] Code follows PEP 8
- [ ] Type hints on function signatures
- [ ] Pydantic models used for validation
- [ ] DB connections use context managers
- [ ] Error handling uses `@safe_operation`
- [ ] UI text in Italian, comments in English/Italian
- [ ] Tested locally (`streamlit run server/app.py`)
- [ ] No hardcoded secrets (use `.env`)
- [ ] Docstrings on public functions
- [ ] UI separated from business logic

---

**Last Updated**: February 17, 2026  
**Philosophy**: Code is Truth. This file describes HOW to code, not WHAT is missing.

*This is the Single Source of Truth for AI assistants working on FitManager AI.*
