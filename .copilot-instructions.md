# üèãÔ∏è FitManager AI Studio - Copilot Instructions

**Project**: FitManager AI Studio  
**Version**: 3.0.0  
**Last Updated**: February 16, 2026  
**Purpose**: AI-powered platform for fitness studio management, personal training, and client tracking

---

## üìã PROJECT OVERVIEW

### What is FitManager AI Studio?

FitManager AI Studio is a **privacy-first, AI-powered fitness management platform** designed for personal trainers, fitness studios, and coaches. It combines traditional CRM capabilities with advanced AI features using **local LLMs** (Ollama) for workout programming, client assessment, and intelligent document analysis.

**Key Differentiator**: Unlike cloud-based SaaS competitors (Trainerize, TrueCoach), FitManager prioritizes **data privacy** by running AI models locally, ensuring client health data never leaves the trainer's infrastructure.

### Current Status (Feb 2026)

- ‚úÖ **Feature Parity**: ~24% vs market leaders
- ‚úÖ **Workout Programming Engine**: RAG-based workout generation (recently implemented)
- ‚úÖ **CRM Module**: Client management with measurements, anamnesis
- ‚úÖ **Financial Intelligence**: MRR tracking, margin analysis
- ‚úÖ **Document Explorer**: RAG system for knowledge base queries
- ‚ö†Ô∏è **Critical Gaps**: Mobile app (0%), Nutrition (0%), Payment integration (0%), Booking system (35%)

### Business Context

**Target Users**: Solo personal trainers, small fitness studios (1-10 trainers), boutique gyms  
**Market Position**: Premium privacy-focused alternative to mass-market SaaS  
**Revenue Model**: One-time license + optional support (vs. subscription SaaS)

---

## üéØ DEVELOPMENT PRIORITIES

### Immediate Priorities (Sprint 1-2)

1. **Mobile App Development** (Critical - 100% gap)
   - React Native or Flutter wrapper for core features
   - Offline-first architecture
   - Workout viewing and completion tracking
   
2. **Payment Integration** (Critical - 55% gap)
   - Stripe integration for subscription billing
   - Invoice generation and auto-payment
   - Dunning management (retry failed payments)

3. **Booking System** (Important - 60% gap)
   - Client-facing booking interface
   - Automated reminders (SMS/Email)
   - Video session integration (Zoom/Google Meet)

### Medium-term Priorities (Sprint 3-4)

4. **Nutrition Module** (80% gap)
   - Macro calculator
   - Meal plan builder
   - Recipe database integration

5. **Photo Analysis** (100% gap)
   - Before/after comparison
   - AI body composition estimation
   - Progress visualization

6. **Exercise Library** (100% gap)
   - 1000+ exercises with videos
   - Custom exercise creation
   - Video demo integration

---

## üèóÔ∏è ARCHITECTURE & TECH STACK

### Directory Structure

```
FitManager_AI_Studio/
‚îú‚îÄ‚îÄ core/                    # Business logic & data access
‚îÇ   ‚îú‚îÄ‚îÄ crm_db.py           # SQLite CRM operations
‚îÇ   ‚îú‚îÄ‚îÄ schedule_db.py      # Agenda & appointments
‚îÇ   ‚îú‚îÄ‚îÄ workout_generator.py # RAG-based workout generation
‚îÇ   ‚îú‚îÄ‚îÄ models.py           # Pydantic validation models
‚îÇ   ‚îú‚îÄ‚îÄ error_handler.py    # Centralized error handling
‚îÇ   ‚îú‚îÄ‚îÄ financial_analytics.py # MRR, churn, margin analysis
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ server/                  # Streamlit web application
‚îÇ   ‚îú‚îÄ‚îÄ app.py              # Main dashboard
‚îÇ   ‚îî‚îÄ‚îÄ pages/              # Multi-page app structure
‚îÇ       ‚îú‚îÄ‚îÄ 01_Agenda.py
‚îÇ       ‚îú‚îÄ‚îÄ 02_Assistente_Esperto.py
‚îÇ       ‚îú‚îÄ‚îÄ 03_Clienti.py
‚îÇ       ‚îú‚îÄ‚îÄ 04_Cassa.py
‚îÇ       ‚îú‚îÄ‚îÄ 07_Programma_Allenamento.py
‚îÇ       ‚îú‚îÄ‚îÄ 09_Financial_Intelligence.py
‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ knowledge_base/          # RAG system
‚îÇ   ‚îú‚îÄ‚îÄ ingest.py           # Document ingestion (PDFs)
‚îÇ   ‚îú‚îÄ‚îÄ ask.py              # Query interface
‚îÇ   ‚îî‚îÄ‚îÄ vectorstore/        # ChromaDB persistence
‚îú‚îÄ‚îÄ tools/                   # Utility modules
‚îÇ   ‚îî‚îÄ‚îÄ schedule_extractor.py
‚îî‚îÄ‚îÄ data/                    # SQLite databases
```

### Technology Stack

**Core Technologies**:
- **Language**: Python 3.9+
- **Web Framework**: Streamlit 1.36.0 (multi-page app)
- **Database**: SQLite (crm.db, schedule.db)
- **AI/LLM**: Ollama (local models: llama3.2, mistral, etc.)
- **RAG/Embeddings**: LangChain + ChromaDB + sentence-transformers
- **Validation**: Pydantic v2
- **Data Processing**: Pandas, NumPy
- **Visualization**: Plotly, Streamlit native charts

**Key Dependencies**:
```toml
streamlit==1.36.0
langchain==0.2.5
langchain-ollama
chromadb==0.4.24
ollama==0.5.4
pydantic>=2.0
pandas==2.2.2
plotly==5.22.0
sentence-transformers==2.7.0
PyMuPDF==1.24.1  # PDF parsing
streamlit-calendar  # Agenda UI
```

### Database Schema (SQLite)

**`crm.db`** - Client Management
```sql
CREATE TABLE clienti (
    id INTEGER PRIMARY KEY,
    nome TEXT NOT NULL,
    cognome TEXT NOT NULL,
    telefono TEXT,
    email TEXT,
    data_nascita DATE,
    sesso TEXT CHECK(sesso IN ('Uomo', 'Donna', 'Altro')),
    data_creazione TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    stato TEXT DEFAULT 'Attivo',
    lezioni_residue INTEGER DEFAULT 0,
    anamnesi_json TEXT
);

CREATE TABLE misurazioni (
    id INTEGER PRIMARY KEY,
    id_cliente INTEGER NOT NULL,
    data_misurazione DATE NOT NULL,
    peso REAL,
    massa_grassa REAL,
    massa_magra REAL,
    acqua REAL,
    collo REAL, spalle REAL, torace REAL,
    braccio REAL, vita REAL, fianchi REAL,
    coscia REAL, polpaccio REAL,
    note TEXT,
    FOREIGN KEY(id_cliente) REFERENCES clienti(id)
);

CREATE TABLE workout_plans (
    id INTEGER PRIMARY KEY,
    id_cliente INTEGER NOT NULL,
    data_creazione TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    titolo TEXT NOT NULL,
    obiettivo TEXT,
    livello TEXT CHECK(livello IN ('Principiante', 'Intermedio', 'Avanzato')),
    durata_settimane INTEGER,
    frequenza_settimanale INTEGER,
    piano_json TEXT NOT NULL,
    note TEXT,
    FOREIGN KEY(id_cliente) REFERENCES clienti(id)
);

CREATE TABLE transazioni (
    id INTEGER PRIMARY KEY,
    id_cliente INTEGER,
    data_transazione DATE NOT NULL,
    tipo TEXT CHECK(tipo IN ('Entrata', 'Uscita')),
    categoria TEXT,
    importo REAL NOT NULL,
    metodo_pagamento TEXT,
    descrizione TEXT,
    FOREIGN KEY(id_cliente) REFERENCES clienti(id)
);
```

**`schedule.db`** - Appointment Management
```sql
CREATE TABLE turni (
    id INTEGER PRIMARY KEY,
    data DATE NOT NULL,
    ora_inizio TEXT NOT NULL,
    ora_fine TEXT NOT NULL,
    tipo_turno TEXT CHECK(tipo_turno IN ('Single PT', 'Group Class', 'Online', 'Assessment')),
    id_cliente INTEGER,
    nome_classe TEXT,
    status TEXT DEFAULT 'Confermato',
    note TEXT,
    colore TEXT DEFAULT '#3788d8'
);
```

---

## üìù CODING STANDARDS & CONVENTIONS

### Python Style Guide

**Follow PEP 8** with these project-specific conventions:

```python
# ‚úÖ GOOD: Clear function names with type hints
def calcola_margine_orario(
    ricavi_mensili: float,
    ore_lavorate: int
) -> float:
    """
    Calcola il margine orario del PT.
    
    Args:
        ricavi_mensili: Ricavi totali del mese (‚Ç¨)
        ore_lavorate: Ore fatturabili lavorate
        
    Returns:
        Margine orario in ‚Ç¨/h
        
    Raises:
        ValueError: Se ore_lavorate <= 0
    """
    if ore_lavorate <= 0:
        raise ValueError("Ore lavorate deve essere > 0")
    return ricavi_mensili / ore_lavorate

# ‚úÖ GOOD: Pydantic models for validation
class ClienteCreate(BaseModel):
    nome: str = Field(min_length=1, max_length=100)
    cognome: str = Field(min_length=1, max_length=100)
    email: Optional[EmailStr] = None
    telefono: Optional[str] = Field(None, pattern=r"^[+]?[0-9\s\-()]{6,20}$")

# ‚ùå BAD: No validation, unclear names
def calc(r, h):
    return r / h
```

### File Organization

**Module Responsibilities**:
- `core/` = Business logic, NO UI code
- `server/` = Streamlit UI, NO business logic (call `core/` functions)
- `models.py` = Pydantic models for ALL data validation
- `error_handler.py` = Use `@safe_operation` decorator for error handling

**Example**: Adding a new CRM feature
```python
# 1. Define model in core/models.py
class NuovoEntity(BaseModel):
    campo: str = Field(...)
    
# 2. Add DB operations in core/crm_db.py
class CrmDBManager:
    def aggiungi_entity(self, data: NuovoEntity) -> int:
        # DB logic here
        
# 3. Create UI in server/pages/XX_Feature.py
import streamlit as st
from core.crm_db import CrmDBManager
from core.models import NuovoEntity

# Use st.form, st.button, etc.
```

### Error Handling Pattern

**Always use the centralized error handler**:

```python
from core.error_handler import safe_operation, log_error, ErrorSeverity

# ‚úÖ GOOD: Wrapped with error handler
@safe_operation(
    error_message="Errore durante il salvataggio del cliente",
    severity=ErrorSeverity.HIGH,
    fallback_return=None
)
def salva_cliente(cliente_data: ClienteCreate) -> Optional[int]:
    db = CrmDBManager()
    return db.aggiungi_cliente(cliente_data)

# ‚ùå BAD: Manual try/except everywhere
def salva_cliente(cliente_data):
    try:
        db = CrmDBManager()
        return db.aggiungi_cliente(cliente_data)
    except Exception as e:
        st.error(f"Errore: {e}")
        return None
```

### Database Operations

**Use context managers for connections**:

```python
# ‚úÖ GOOD: Context manager ensures connection closure
class CrmDBManager:
    def get_cliente(self, id_cliente: int) -> Optional[dict]:
        with sqlite3.connect(self.db_path) as conn:
            cur = conn.cursor()
            cur.execute("SELECT * FROM clienti WHERE id = ?", (id_cliente,))
            row = cur.fetchone()
            return dict(row) if row else None

# ‚ùå BAD: Manual connection management
def get_cliente(id_cliente):
    conn = sqlite3.connect("crm.db")
    cur = conn.cursor()
    cur.execute(...)
    # Forgot to close connection!
```

### Streamlit Best Practices

**Use session state for data persistence**:

```python
# ‚úÖ GOOD: Initialize session state properly
if "clienti_cache" not in st.session_state:
    st.session_state.clienti_cache = []

# Use forms for input validation
with st.form("nuovo_cliente_form"):
    nome = st.text_input("Nome*", max_chars=100)
    cognome = st.text_input("Cognome*", max_chars=100)
    submitted = st.form_submit_button("Salva")
    
    if submitted:
        # Validate with Pydantic
        try:
            cliente = ClienteCreate(nome=nome, cognome=cognome)
            salva_cliente(cliente)
        except ValidationError as e:
            st.error(f"Dati non validi: {e}")

# ‚ùå BAD: Direct buttons without forms (causes re-renders)
nome = st.text_input("Nome")
if st.button("Salva"):  # This will rerun entire script
    salva_cliente(nome)
```

---

## ü§ñ AI/RAG SYSTEM GUIDELINES

### LangChain + Ollama Architecture

**Current Setup**:
- **Model**: Ollama-hosted models (llama3.2, mistral, qwen2.5)
- **Embeddings**: sentence-transformers (all-MiniLM-L6-v2)
- **Vector Store**: ChromaDB (persistent at `knowledge_base/vectorstore/`)
- **Document Types**: PDF, TXT, Markdown

### RAG Workflow

```python
# knowledge_base/ingest.py - Document Ingestion
from langchain_community.document_loaders import PyMuPDFLoader
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_chroma import Chroma

def ingest_documents(pdf_paths: List[str]) -> None:
    """
    Ingest PDFs into ChromaDB vector store.
    
    Process:
    1. Load PDFs with PyMuPDF
    2. Split into chunks (1000 chars, 200 overlap)
    3. Embed with sentence-transformers
    4. Store in ChromaDB
    """
    docs = []
    for path in pdf_paths:
        loader = PyMuPDFLoader(path)
        docs.extend(loader.load())
    
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=1000,
        chunk_overlap=200
    )
    splits = text_splitter.split_documents(docs)
    
    vectorstore = Chroma.from_documents(
        documents=splits,
        embedding=OllamaEmbeddings(model="llama3.2"),
        persist_directory="./vectorstore"
    )

# knowledge_base/ask.py - Query Interface
def query_knowledge_base(question: str, chat_history: List = None) -> str:
    """
    Query RAG system with conversational context.
    
    Args:
        question: User question
        chat_history: Previous (question, answer) tuples
        
    Returns:
        AI-generated answer with sources
    """
    vectorstore = Chroma(
        persist_directory="./vectorstore",
        embedding_function=OllamaEmbeddings(model="llama3.2")
    )
    
    retriever = vectorstore.as_retriever(
        search_type="similarity",
        search_kwargs={"k": 5}
    )
    
    llm = ChatOllama(model="llama3.2", temperature=0.2)
    
    chain = ConversationalRetrievalChain.from_llm(
        llm=llm,
        retriever=retriever,
        return_source_documents=True
    )
    
    result = chain({"question": question, "chat_history": chat_history or []})
    return result["answer"]
```

### Prompt Engineering Guidelines

**Use system prompts for role definition**:

```python
# ‚úÖ GOOD: Clear system prompt with role and constraints
WORKOUT_SYSTEM_PROMPT = """Sei un personal trainer esperto con certificazione NSCA-CPT.

COMPITO: Genera programmi di allenamento personalizzati basati su:
- Livello del cliente (Principiante/Intermedio/Avanzato)
- Obiettivo (Forza, Ipertrofia, Resistenza, Ricomposizione)
- Frequenza settimanale (2-6 sessioni)
- Equipment disponibile
- Eventuali limitazioni fisiche

FORMATO OUTPUT: JSON strutturato con:
{
  "settimane": [
    {
      "numero": 1,
      "sessioni": [
        {
          "giorno": "Luned√¨",
          "focus": "Upper Body",
          "esercizi": [...]
        }
      ]
    }
  ]
}

VINCOLI:
- Rispetta progressione logica (principio sovraccarico progressivo)
- Include sempre riscaldamento e defaticamento
- Max 8 esercizi per sessione
- Specifica serie, ripetizioni, recupero
"""

# ‚ùå BAD: Vague prompt with no structure
prompt = "Genera un allenamento per un cliente"
```

### AI Model Selection

**Use appropriate models per task**:

| Task | Recommended Model | Temperature | Context Window |
|------|-------------------|-------------|----------------|
| Workout Generation | `llama3.2` | 0.3 | 8K tokens |
| Document Q&A | `mistral` | 0.2 | 8K tokens |
| Creative Suggestions | `qwen2.5` | 0.7 | 32K tokens |
| Code Generation | `codellama` | 0.1 | 16K tokens |

---

## üß™ TESTING STRATEGY

### Current Testing Status

‚ö†Ô∏è **Testing is currently minimal** - this is a known gap.

### Testing Roadmap

**Priority 1: Critical Path Testing**
```python
# tests/test_crm_db.py
import pytest
from core.crm_db import CrmDBManager
from core.models import ClienteCreate

@pytest.fixture
def db_manager(tmp_path):
    """Create temporary test database"""
    db_path = tmp_path / "test_crm.db"
    return CrmDBManager(db_path=str(db_path))

def test_aggiungi_cliente(db_manager):
    """Test client creation with valid data"""
    cliente = ClienteCreate(
        nome="Mario",
        cognome="Rossi",
        email="mario@example.com"
    )
    cliente_id = db_manager.aggiungi_cliente(cliente)
    assert cliente_id > 0
    
    # Verify persistence
    retrieved = db_manager.get_cliente(cliente_id)
    assert retrieved["nome"] == "Mario"
    assert retrieved["cognome"] == "Rossi"

def test_aggiungi_cliente_invalid_email(db_manager):
    """Test that invalid email raises ValidationError"""
    with pytest.raises(ValidationError):
        cliente = ClienteCreate(
            nome="Mario",
            cognome="Rossi",
            email="invalid-email"  # Missing @
        )
```

**Priority 2: Integration Testing**
- Test RAG workflow end-to-end
- Test Streamlit page rendering
- Test database migrations

**Priority 3: Performance Testing**
- RAG query response time (<2s)
- Database query optimization
- Streamlit page load time

---

## üîê SECURITY & PRIVACY

### Data Privacy Principles

**Core Philosophy**: FitManager's competitive advantage is **privacy-first architecture**.

1. **Local AI Processing**: All LLM operations run on Ollama (local server), not cloud
2. **SQLite Local Storage**: Client data stored locally, not cloud databases
3. **No Telemetry**: No analytics tracking by default
4. **GDPR Compliance**: Export/delete client data functionality

### Security Best Practices

```python
# ‚úÖ GOOD: Parameterized queries (prevent SQL injection)
cur.execute(
    "SELECT * FROM clienti WHERE email = ? AND nome = ?",
    (email, nome)
)

# ‚ùå BAD: String formatting (SQL injection risk)
cur.execute(f"SELECT * FROM clienti WHERE email = '{email}'")

# ‚úÖ GOOD: Validate file uploads
def upload_pdf(file: UploadedFile) -> bool:
    """Validate PDF before ingestion"""
    if not file.name.endswith(".pdf"):
        raise ValueError("Solo file PDF ammessi")
    if file.size > 10 * 1024 * 1024:  # 10MB limit
        raise ValueError("File troppo grande (max 10MB)")
    return True

# ‚úÖ GOOD: Environment variables for sensitive data
from dotenv import load_dotenv
load_dotenv()

STRIPE_API_KEY = os.getenv("STRIPE_API_KEY")  # Never hardcode!
```

### Password/Auth Strategy

**Current Status**: No authentication system (local desktop app)

**Future Requirement** (Multi-user mode):
- Use `bcrypt` for password hashing
- Implement role-based access (Admin, Trainer, Receptionist)
- JWT tokens for API authentication

---

## üìö KEY DOCUMENTATION FILES

### Essential Reading (Prioritized)

1. **[START_HERE.md](START_HERE.md)** - Project overview and navigation guide
2. **[PROJECT_STATUS.md](PROJECT_STATUS.md)** - Current feature status, roadmap
3. **[ANALISI_COMPETITIVA_LACUNE.md](ANALISI_COMPETITIVA_LACUNE.md)** - Competitive analysis, identified gaps
4. **[QUICK_START_WORKOUT_ENGINE.md](QUICK_START_WORKOUT_ENGINE.md)** - RAG workout system guide

### Implementation Guides

5. **[PIANO_AZIONE_TECNICO.md](PIANO_AZIONE_TECNICO.md)** - Technical action plan (13 tasks)
6. **[IMPLEMENTAZIONE_WORKOUT_ENGINE.md](IMPLEMENTAZIONE_WORKOUT_ENGINE.md)** - Workout system implementation details
7. **[GUIDA_FINANCIAL_INTELLIGENCE.md](GUIDA_FINANCIAL_INTELLIGENCE.md)** - Financial module documentation

### Reference Documents

8. **[INDEX.md](INDEX.md)** - Master index of all documentation
9. **[FORMULE_FINANZIARIE.md](FORMULE_FINANZIARIE.md)** - Financial calculation formulas
10. **[QUICK_REFERENCE_FINANCIAL_SYSTEM.md](QUICK_REFERENCE_FINANCIAL_SYSTEM.md)** - Financial system quick reference

---

## üöÄ COMMON DEVELOPMENT TASKS

### Adding a New Streamlit Page

```bash
# 1. Create page file (filename determines order)
touch server/pages/11_New_Feature.py

# 2. Basic page template
cat > server/pages/11_New_Feature.py << 'EOF'
# file: server/pages/11_New_Feature.py
"""
Descrizione della nuova feature
"""
import streamlit as st
import sys
import os

# Path setup
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "../..")))

from core.crm_db import CrmDBManager
from core.models import NuovoModel

st.set_page_config(page_title="New Feature", page_icon="üéØ", layout="wide")

# Main UI
st.title("üéØ New Feature")

# Your implementation here...
EOF

# 3. Test the page
streamlit run server/app.py
```

### Adding a New Database Table

```python
# 1. Define model in core/models.py
class NuovaEntity(BaseModel):
    id_cliente: int = Field(gt=0)
    campo1: str = Field(min_length=1)
    campo2: Optional[float] = None

# 2. Create table in appropriate DB manager (e.g., core/crm_db.py)
def _create_tables(self):
    """Create all required tables"""
    with sqlite3.connect(self.db_path) as conn:
        cur = conn.cursor()
        
        # Existing tables...
        
        # New table
        cur.execute("""
            CREATE TABLE IF NOT EXISTS nuova_tabella (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                id_cliente INTEGER NOT NULL,
                campo1 TEXT NOT NULL,
                campo2 REAL,
                data_creazione TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(id_cliente) REFERENCES clienti(id)
            )
        """)
        conn.commit()

# 3. Add CRUD methods
def aggiungi_entity(self, data: NuovaEntity) -> int:
    """Add new entity to database"""
    with sqlite3.connect(self.db_path) as conn:
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO nuova_tabella (id_cliente, campo1, campo2)
            VALUES (?, ?, ?)
        """, (data.id_cliente, data.campo1, data.campo2))
        conn.commit()
        return cur.lastrowid
```

### Integrating a New AI Feature

```python
# 1. Add prompt template in appropriate module
NUOVA_FEATURE_PROMPT = """Sei un esperto di [domain].

COMPITO: [task description]

INPUT:
{input_data}

OUTPUT FORMAT:
[specify JSON structure or text format]

VINCOLI:
- [constraint 1]
- [constraint 2]
"""

# 2. Create function using LangChain
from langchain_ollama import ChatOllama

def genera_suggerimento_ai(input_data: dict) -> str:
    """Generate AI suggestion for new feature"""
    llm = ChatOllama(
        model="llama3.2",
        temperature=0.3
    )
    
    prompt = NUOVA_FEATURE_PROMPT.format(input_data=json.dumps(input_data))
    response = llm.invoke(prompt)
    
    return response.content

# 3. Add UI in Streamlit page
if st.button("Genera Suggerimento AI"):
    with st.spinner("Elaborazione in corso..."):
        suggerimento = genera_suggerimento_ai(input_data)
        st.success("Suggerimento generato!")
        st.markdown(suggerimento)
```

### Adding External API Integration

```python
# 1. Add dependency to pyproject.toml
# dependencies = [
#     "stripe==5.2.0",  # Example
# ]

# 2. Create new module in core/ (e.g., core/payment_api.py)
import stripe
import os
from dotenv import load_dotenv

load_dotenv()
stripe.api_key = os.getenv("STRIPE_API_KEY")

class PaymentManager:
    """Handle payment operations via Stripe"""
    
    def crea_pagamento(self, importo: float, cliente_email: str) -> dict:
        """Create payment intent"""
        try:
            payment_intent = stripe.PaymentIntent.create(
                amount=int(importo * 100),  # Stripe uses cents
                currency="eur",
                receipt_email=cliente_email,
                metadata={
                    "integration": "fitmanager_ai"
                }
            )
            return {
                "success": True,
                "payment_id": payment_intent.id,
                "client_secret": payment_intent.client_secret
            }
        except stripe.error.StripeError as e:
            return {
                "success": False,
                "error": str(e)
            }

# 3. Use in Streamlit page
from core.payment_api import PaymentManager

payment_mgr = PaymentManager()
result = payment_mgr.crea_pagamento(100.0, "cliente@example.com")

if result["success"]:
    st.success(f"Pagamento creato: {result['payment_id']}")
else:
    st.error(f"Errore: {result['error']}")
```

---

## üêõ DEBUGGING & TROUBLESHOOTING

### Common Issues

**Issue 1: Ollama Connection Error**
```python
# Error: "Could not connect to Ollama at http://localhost:11434"

# Solution 1: Check if Ollama is running
# PowerShell:
ollama list  # Should show installed models

# Solution 2: Start Ollama service
ollama serve

# Solution 3: Verify model is pulled
ollama pull llama3.2
```

**Issue 2: ChromaDB Persistence Issues**
```python
# Error: "Vector store empty after restart"

# Solution: Ensure persist_directory is correctly set
vectorstore = Chroma(
    persist_directory="./knowledge_base/vectorstore",  # Absolute path better
    embedding_function=OllamaEmbeddings(model="llama3.2")
)

# Verify files exist
# Should see: chroma.sqlite3 + UUID folders in vectorstore/
```

**Issue 3: Streamlit Session State Lost**
```python
# Issue: Data disappears on page navigation

# Solution: Initialize at top of EVERY page
if "clienti_cache" not in st.session_state:
    st.session_state.clienti_cache = []

# Use st.cache_data for expensive operations
@st.cache_data(ttl=300)  # Cache for 5 minutes
def load_clienti() -> List[dict]:
    db = CrmDBManager()
    return db.get_all_clienti()
```

**Issue 4: Database Locked (SQLite)**
```python
# Error: "database is locked"

# Solution 1: Always use context managers
with sqlite3.connect(db_path) as conn:
    # Operations here
    pass  # Connection auto-closed

# Solution 2: Increase timeout
conn = sqlite3.connect(db_path, timeout=10.0)

# Solution 3: Use WAL mode (better concurrency)
conn.execute("PRAGMA journal_mode=WAL")
```

### Logging & Diagnostics

```python
# Enable logging in development
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("logs/fitmanager.log"),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# Use throughout code
logger.debug("Connecting to database...")
logger.info(f"Client {cliente_id} created successfully")
logger.warning("Unusual data pattern detected")
logger.error(f"Failed to generate workout: {e}")
```

---

## üé® UI/UX GUIDELINES

### Streamlit Design Principles

**Consistent Layout**:
```python
# ‚úÖ GOOD: Consistent page structure
st.title("üéØ Feature Name")
st.markdown("Brief description of what this page does")

# Sidebar for filters/options
with st.sidebar:
    st.header("‚öôÔ∏è Opzioni")
    filtro = st.selectbox("Filtra per", ["Tutti", "Attivi", "Inattivi"])

# Main content in columns
col1, col2 = st.columns([2, 1])
with col1:
    # Primary content
    pass
with col2:
    # Secondary info / stats
    pass
```

**Color Scheme** (Already in `app.py` CSS):
- **Primary**: `#0066cc` (Blue) - Call-to-action buttons
- **Secondary**: `#00a86b` (Green) - Success states
- **Accent**: `#ff6b35` (Orange) - Warnings/highlights
- **Danger**: `#e74c3c` (Red) - Errors/deletions

**Component Standards**:
```python
# Forms: Always use st.form for grouped inputs
with st.form("form_name"):
    col1, col2 = st.columns(2)
    with col1:
        campo1 = st.text_input("Campo 1*", help="Tooltip text")
    with col2:
        campo2 = st.number_input("Campo 2", min_value=0)
    
    submitted = st.form_submit_button("üíæ Salva", use_container_width=True)

# Metrics: Use st.metric for KPIs
col1, col2, col3 = st.columns(3)
col1.metric("MRR", "‚Ç¨3,500", "+12%")
col2.metric("Clienti Attivi", "42", "+3")
col3.metric("Margine Orario", "‚Ç¨87.50", "+5%")

# Tables: Use st.dataframe with configuration
st.dataframe(
    df,
    use_container_width=True,
    hide_index=True,
    column_config={
        "email": st.column_config.TextColumn("Email", width="medium"),
        "importo": st.column_config.NumberColumn("Importo", format="‚Ç¨%.2f")
    }
)
```

---

## üìñ GLOSSARY & TERMINOLOGY

### Italian Fitness Terms (Used in UI)

- **Anamnesi**: Medical history / client questionnaire
- **Margine Orario**: Hourly margin (revenue per billable hour)
- **MRR**: Monthly Recurring Revenue
- **Lezioni Residue**: Remaining sessions (in client's package)
- **Turno**: Shift / appointment slot
- **Misurazioni**: Body measurements
- **Massa Grassa**: Body fat percentage
- **Massa Magra**: Lean body mass
- **Circonferenze**: Circumferences (body measurements)
- **Scheda di Allenamento**: Workout program
- **Periodizzazione**: Periodization (training phase structure)
- **Microciclo**: Microcycle (1 week training block)
- **Mesociclo**: Mesocycle (3-6 week training phase)
- **Macrociclo**: Macrocycle (12+ week training plan)

### Technical Abbreviations

- **RAG**: Retrieval-Augmented Generation (AI technique)
- **LLM**: Large Language Model
- **PT**: Personal Trainer
- **CRM**: Customer Relationship Management
- **MRR**: Monthly Recurring Revenue
- **LTV**: Lifetime Value (customer)
- **CAC**: Customer Acquisition Cost
- **RPE**: Rate of Perceived Exertion (training intensity)
- **1RM**: One Rep Max (strength measurement)

---

## ‚öôÔ∏è ENVIRONMENT SETUP

### Initial Setup (New Developer)

```powershell
# 1. Clone repository (if applicable)
# git clone <repo-url>
cd FitManager_AI_Studio

# 2. Create virtual environment
python -m venv venv
.\venv\Scripts\Activate.ps1

# 3. Install dependencies
pip install -e .

# 4. Install Ollama (if not installed)
# Download from https://ollama.ai
ollama pull llama3.2
ollama pull mistral

# 5. Create .env file (optional for future API keys)
echo "STRIPE_API_KEY=sk_test_..." > .env
echo "OPENAI_API_KEY=..." >> .env  # If using OpenAI fallback

# 6. Initialize databases (auto-created on first run)
# No manual setup needed - SQLite auto-creates

# 7. Run application
streamlit run server/app.py
```

### Development Environment Variables

```bash
# .env file (optional - for future integrations)

# Payments
STRIPE_API_KEY=sk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...

# Email/SMS (future)
SENDGRID_API_KEY=SG...
TWILIO_ACCOUNT_SID=AC...
TWILIO_AUTH_TOKEN=...

# Video Conferencing (future)
ZOOM_API_KEY=...
ZOOM_API_SECRET=...

# AI (if using cloud fallback)
OPENAI_API_KEY=sk-...

# Database (if migrating to PostgreSQL)
DATABASE_URL=postgresql://user:pass@localhost:5432/fitmanager
```

---

## üéØ CONTEXT FOR AI ASSISTANTS

### When Generating Code

**Always consider**:
1. **Language**: User prefers Italian UI text, English code comments accepted
2. **Framework**: Streamlit multi-page app (not Flask/Django)
3. **Database**: SQLite with context managers (not ORM)
4. **Validation**: Use Pydantic models before DB operations
5. **AI**: Prefer Ollama (local) over OpenAI (cloud)
6. **Privacy**: Never suggest cloud storage for client health data

### When Suggesting Features

**Prioritize**:
1. Features that close competitive gaps (see ANALISI_COMPETITIVA_LACUNE.md)
2. Privacy-preserving solutions (local processing)
3. Mobile-first experience (future React Native app)
4. Offline capability (core features work without internet)

**Avoid suggesting**:
- Cloud-based AI services (OpenAI, Claude) unless fallback
- Third-party analytics/tracking (privacy violation)
- Desktop-only features (think mobile-first)
- Over-engineered solutions (keep it simple)

### When Debugging

**Check these first**:
1. Is Ollama running? (`ollama list`)
2. Are databases initialized? (check `data/` folder)
3. Is virtual environment activated? (see `(venv)` in terminal)
4. Are dependencies up-to-date? (`pip list`)
5. Check `logs/` folder for error traces

---

## üìû PROJECT CONTACTS & RESOURCES

### Key Resources

- **Project Lead**: G. Verardo
- **Main Application**: `streamlit run server/app.py`
- **Documentation Index**: [INDEX.md](INDEX.md)
- **Status Dashboard**: [PROJECT_STATUS.md](PROJECT_STATUS.md)

### External Dependencies Docs

- **Streamlit**: https://docs.streamlit.io
- **LangChain**: https://python.langchain.com/docs/
- **Ollama**: https://ollama.ai/library
- **ChromaDB**: https://docs.trychroma.com
- **Pydantic**: https://docs.pydantic.dev

---

## üîÑ CHANGELOG & VERSIONING

### Version 3.0.0 (Current - Jan 17, 2026)

**Added**:
- ‚úÖ Workout Programming Engine (RAG-based)
- ‚úÖ Document Explorer with PDF ingestion
- ‚úÖ Financial Intelligence module (MRR, margin analysis)
- ‚úÖ Pydantic validation layer (`models.py`)
- ‚úÖ Centralized error handling (`error_handler.py`)
- ‚úÖ Streamlit Calendar integration

**Fixed**:
- üêõ Client page (02_Clienti.py) critical bug
- üêõ Financial calculation errors (see CORREZIONE_LOGICA_FINANZIARIA.md)

**In Progress**:
- üöß Mobile app (React Native) - 0% complete
- üöß Payment integration (Stripe) - 0% complete
- üöß Nutrition module - 0% complete

### Roadmap to 4.0.0 (Target: Q2 2026)

- Mobile app MVP (workout viewing, progress tracking)
- Payment gateway integration (Stripe)
- Booking system (client-facing)
- Email/SMS automation
- Exercise library (1000+ exercises)

---

## üìã QUICK REFERENCE

### Useful Commands

```powershell
# Activate environment
.\venv\Scripts\Activate.ps1

# Run main app
streamlit run server/app.py

# Run specific page
streamlit run server/pages/07_Programma_Allenamento.py

# Check Ollama models
ollama list

# Pull new model
ollama pull qwen2.5

# Test Ollama API
ollama run llama3.2 "Ciao, come stai?"

# Database inspection (SQLite)
sqlite3 data/crm.db
# Inside SQLite shell:
# .tables  (show tables)
# .schema clienti  (show table structure)
# SELECT * FROM clienti;  (query data)
# .quit  (exit)

# Install new dependency
pip install <package>
# Then update pyproject.toml dependencies

# Format code (if using black)
black core/ server/

# Type checking (if using mypy)
mypy core/

# Run tests (when implemented)
pytest tests/
```

### File Locations Quick Reference

| Task | File Path |
|------|-----------|
| Add CRM feature | `core/crm_db.py` |
| Add validation model | `core/models.py` |
| Add Streamlit page | `server/pages/XX_Name.py` |
| Modify AI prompts | `core/workout_generator.py`, `knowledge_base/ask.py` |
| Database schema | See docstrings in `core/crm_db.py`, `core/schedule_db.py` |
| Financial logic | `core/financial_analytics.py` |
| Error handling | `core/error_handler.py` |
| UI styling | `server/app.py` (CSS in markdown) |

---

## üéì LEARNING RESOURCES

### For New Contributors

**If you're new to the stack**:

1. **Streamlit** (2 hours): https://docs.streamlit.io/get-started
2. **LangChain Basics** (3 hours): https://python.langchain.com/docs/tutorials/
3. **Ollama Setup** (1 hour): https://ollama.ai/download
4. **Pydantic V2** (2 hours): https://docs.pydantic.dev/latest/

**Project-specific learning path**:

1. Read [START_HERE.md](START_HERE.md) (15 min)
2. Read [QUICK_START_WORKOUT_ENGINE.md](QUICK_START_WORKOUT_ENGINE.md) (10 min)
3. Run the app: `streamlit run server/app.py` (5 min)
4. Explore pages: Try creating a client, adding measurements, generating workout (30 min)
5. Read [ANALISI_COMPETITIVA_LACUNE.md](ANALISI_COMPETITIVA_LACUNE.md) to understand gaps (30 min)
6. Pick a task from [PIANO_AZIONE_TECNICO.md](PIANO_AZIONE_TECNICO.md) (variable)

---

## ‚úÖ FINAL CHECKLIST (Before Committing Code)

- [ ] Code follows PEP 8 style guide
- [ ] Added type hints to function signatures
- [ ] Used Pydantic models for validation
- [ ] Database connections use context managers
- [ ] Error handling uses `@safe_operation` decorator
- [ ] UI text in Italian, code comments in English/Italian
- [ ] Tested locally with `streamlit run`
- [ ] No hardcoded API keys (use .env)
- [ ] Added docstrings to public functions
- [ ] Updated relevant documentation files (if needed)

---

**Last Updated**: February 16, 2026  
**Maintained By**: FitManager AI Studio Development Team

*This file is the single source of truth for AI assistants (GitHub Copilot, Cursor, etc.) working on this project.*
